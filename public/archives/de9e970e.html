<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Prometheus-PromQL | 尤妤</title><meta name="keywords" content="Prometheus,监控"><meta name="author" content="尤妤"><meta name="copyright" content="尤妤"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="理解时间序列通过Node Exporter暴露的HTTP服务，Prometheus可以采集到当前主机所有监控指标的样本数据。例如： 123456# HELP node_cpu Seconds the cpus spent in each mode.# TYPE node_cpu counternode_cpu&amp;#123;cpu&#x3D;&quot;cpu0&quot;,mode&#x3D;&quot;idle&amp;qu">
<meta property="og:type" content="article">
<meta property="og:title" content="Prometheus-PromQL">
<meta property="og:url" content="https://www.xiaowangc.com/archives/de9e970e.html">
<meta property="og:site_name" content="尤妤">
<meta property="og:description" content="理解时间序列通过Node Exporter暴露的HTTP服务，Prometheus可以采集到当前主机所有监控指标的样本数据。例如： 123456# HELP node_cpu Seconds the cpus spent in each mode.# TYPE node_cpu counternode_cpu&amp;#123;cpu&#x3D;&quot;cpu0&quot;,mode&#x3D;&quot;idle&amp;qu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.xiaowangc.com/img/fengmian/Prometheus.jpg">
<meta property="article:published_time" content="2022-11-15T03:04:50.000Z">
<meta property="article:modified_time" content="2022-11-17T01:41:26.000Z">
<meta property="article:author" content="尤妤">
<meta property="article:tag" content="Prometheus">
<meta property="article:tag" content="监控">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.xiaowangc.com/img/fengmian/Prometheus.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="https://www.xiaowangc.com/archives/de9e970e"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 尤妤","link":"链接: ","source":"来源: 尤妤","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Prometheus-PromQL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-17 09:41:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-screwdriver-wrench"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://api.xiaowangc.com"><i class="fa-fw fas fa-location-dot"></i><span> IP地址查询</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://decoder.link/"><i class="fa-fw fa-brands fa-expeditedssl"></i><span> TLS检测工具</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://freessl.cn/"><i class="fa-fw fas fa-lock"></i><span> TLS证书申请1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://letsencrypt.org/"><i class="fa-fw fas fa-lock"></i><span> TLS证书申请2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.sslforfree.com/"><i class="fa-fw fas fa-lock"></i><span> TLS证书申请3</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://awesome-prometheus-alerts.grep.to/"><i class="fa-fw fa-brands fa-watchman-monitoring"></i><span> PromAlertRules</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://ssl-config.mozilla.org/"><i class="fa-fw fa-brands fa-expeditedssl"></i><span> TLS配置生成器</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/fengmian/Prometheus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">尤妤</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-screwdriver-wrench"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://api.xiaowangc.com"><i class="fa-fw fas fa-location-dot"></i><span> IP地址查询</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://decoder.link/"><i class="fa-fw fa-brands fa-expeditedssl"></i><span> TLS检测工具</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://freessl.cn/"><i class="fa-fw fas fa-lock"></i><span> TLS证书申请1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://letsencrypt.org/"><i class="fa-fw fas fa-lock"></i><span> TLS证书申请2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.sslforfree.com/"><i class="fa-fw fas fa-lock"></i><span> TLS证书申请3</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://awesome-prometheus-alerts.grep.to/"><i class="fa-fw fa-brands fa-watchman-monitoring"></i><span> PromAlertRules</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://ssl-config.mozilla.org/"><i class="fa-fw fa-brands fa-expeditedssl"></i><span> TLS配置生成器</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Prometheus-PromQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-15T03:04:50.000Z" title="发表于 2022-11-15 11:04:50">2022-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-17T01:41:26.000Z" title="更新于 2022-11-17 09:41:26">2022-11-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9B%91%E6%8E%A7/">监控</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Prometheus-PromQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="理解时间序列"><a href="#理解时间序列" class="headerlink" title="理解时间序列"></a>理解时间序列</h1><p>通过Node Exporter暴露的HTTP服务，Prometheus可以采集到当前主机所有监控指标的样本数据。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HELP node_cpu Seconds the cpus spent in each mode.</span><br><span class="line"># TYPE node_cpu counter</span><br><span class="line">node_cpu&#123;cpu=&quot;cpu0&quot;,mode=&quot;idle&quot;&#125; 362812.7890625</span><br><span class="line"># HELP node_load1 1m load average.</span><br><span class="line"># TYPE node_load1 gauge</span><br><span class="line">node_load1 3.0703125</span><br></pre></td></tr></table></figure>

<p>其中非#开头的每一行表示当前Node Exporter采集到的一个监控样本：node_cpu和node_load1表明了当前指标的名称、大括号中的标签则反映了当前样本的一些特征和维度、浮点数则是该监控样本的具体值。</p>
<h2 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h2><p>Prometheus会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，并且定时保存到硬盘上。time-series是按照时间戳和值的序列顺序存放的，我们称之为向量(vector). 每条time-series通过指标名称(metrics name)和一组标签集(labelset)命名。如下所示，可以将time-series理解为一个以时间为Y轴的数字矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">│   . . . . . . . . . . . . . . . . .   . .   node_cpu&#123;cpu=&quot;cpu0&quot;,mode=&quot;idle&quot;&#125;</span><br><span class="line">│     . . . . . . . . . . . . . . . . . . .   node_cpu&#123;cpu=&quot;cpu0&quot;,mode=&quot;system&quot;&#125;</span><br><span class="line">│     . . . . . . . . . .   . . . . . . . .   node_load1&#123;&#125;</span><br><span class="line">│     . . . . . . . . . . . . . . . .   . .  </span><br><span class="line">v</span><br><span class="line">  &lt;------------------ 时间 ----------------&gt;</span><br></pre></td></tr></table></figure>

<p>在time-series中的每一个点称为一个样本（sample），样本由以下三部分组成：</p>
<ul>
<li>指标(metric)：metric name和描述当前样本特征的labelsets;</li>
<li>时间戳(timestamp)：一个精确到毫秒的时间戳;</li>
<li>样本值(value)： 一个float64的浮点型数据表示当前样本的值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt;</span><br><span class="line">http_request_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;@1434417560938 =&gt; 94355</span><br><span class="line">http_request_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;@1434417561287 =&gt; 94334</span><br><span class="line"></span><br><span class="line">http_request_total&#123;status=&quot;404&quot;, method=&quot;GET&quot;&#125;@1434417560938 =&gt; 38473</span><br><span class="line">http_request_total&#123;status=&quot;404&quot;, method=&quot;GET&quot;&#125;@1434417561287 =&gt; 38544</span><br><span class="line"></span><br><span class="line">http_request_total&#123;status=&quot;200&quot;, method=&quot;POST&quot;&#125;@1434417560938 =&gt; 4748</span><br><span class="line">http_request_total&#123;status=&quot;200&quot;, method=&quot;POST&quot;&#125;@1434417561287 =&gt; 4785</span><br></pre></td></tr></table></figure>

<h2 id="指标-Metric"><a href="#指标-Metric" class="headerlink" title="指标(Metric)"></a>指标(Metric)</h2><p>在形式上，所有的指标(Metric)都通过如下格式标示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br></pre></td></tr></table></figure>

<p>指标的名称(metric name)可以反映被监控样本的含义（比如，<code>http_request_total</code> - 表示当前系统接收到的HTTP请求总量）。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式<code>[a-zA-Z_:][a-zA-Z0-9_:]*</code>。</p>
<p>标签(label)反映了当前样本的特征维度，通过这些维度Prometheus可以对样本数据进行过滤，聚合等。标签的名称只能由ASCII字符、数字以及下划线组成并满足正则表达式<code>[a-zA-Z_][a-zA-Z0-9_]*</code>。</p>
<p>其中以<code>__</code>作为前缀的标签，是系统保留的关键字，只能在系统内部使用。标签的值则可以包含任何Unicode编码的字符。在Prometheus的底层实现中指标名称实际上是以<code>__name__=&lt;metric name&gt;</code>的形式保存在数据库中的，因此以下两种方式均表示的同一条time-series：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api_http_requests_total&#123;method=&quot;POST&quot;, handler=&quot;/messages&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__=&quot;api_http_requests_total&quot;，method=&quot;POST&quot;, handler=&quot;/messages&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>在Prometheus源码中也可以找到指标(Metric)对应的数据结构，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Metric LabelSet</span><br><span class="line"></span><br><span class="line">type LabelSet map[LabelName]LabelValue</span><br><span class="line"></span><br><span class="line">type LabelName string</span><br><span class="line"></span><br><span class="line">type LabelValue string</span><br></pre></td></tr></table></figure>



<h1 id="Metric类型"><a href="#Metric类型" class="headerlink" title="Metric类型"></a>Metric类型</h1><p>在上一小节中我们带领读者了解了Prometheus的底层数据模型，在Prometheus的存储实现上所有的监控样本都是以time-series的形式保存在Prometheus内存的TSDB（时序数据库）中，而time-series所对应的监控指标(metric)也是通过labelset进行唯一命名的。</p>
<p>从存储上来讲所有的监控指标metric都是相同的，但是在不同的场景下这些metric又有一些细微的差异。 例如，在Node Exporter返回的样本中指标node_load1反应的是当前系统的负载状态，随着时间的变化这个指标返回的样本数据是在不断变化的。而指标node_cpu所获取到的样本数据却不同，它是一个持续增大的值，因为其反应的是CPU的累积使用时间，从理论上讲只要系统不关机，这个值是会无限变大的。</p>
<p>为了能够帮助用户理解和区分这些不同监控指标之间的差异，Prometheus定义了4种不同的指标类型(metric type)：Counter（计数器）、Gauge（仪表盘）、Histogram（直方图）、Summary（摘要）。</p>
<p>在Exporter返回的样本数据中，其注释中也包含了该样本的类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># HELP node_cpu Seconds the cpus spent in each mode.</span><br><span class="line"># TYPE node_cpu counter</span><br><span class="line">node_cpu&#123;cpu=&quot;cpu0&quot;,mode=&quot;idle&quot;&#125; 362812.7890625</span><br></pre></td></tr></table></figure>

<h2 id="Counter：只增不减的计数器"><a href="#Counter：只增不减的计数器" class="headerlink" title="Counter：只增不减的计数器"></a>Counter：只增不减的计数器</h2><p>Counter类型的指标其工作方式和计数器一样，只增不减（除非系统发生重置）。常见的监控指标，如http_requests_total，node_cpu都是Counter类型的监控指标。 一般在定义Counter类型指标的名称时推荐使用_total作为后缀。</p>
<p>Counter是一个简单但有强大的工具，例如我们可以在应用程序中记录某些事件发生的次数，通过以时序的形式存储这些数据，我们可以轻松的了解该事件产生速率的变化。<br>PromQL内置的聚合操作和函数可以让用户对这些数据进行进一步的分析：</p>
<p>例如，通过rate()函数获取HTTP请求量的增长率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure>

<p>查询当前系统中，访问量前10的HTTP地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(10, http_requests_total)</span><br></pre></td></tr></table></figure>

<h2 id="Gauge：可增可减的仪表盘"><a href="#Gauge：可增可减的仪表盘" class="headerlink" title="Gauge：可增可减的仪表盘"></a>Gauge：可增可减的仪表盘</h2><p>与Counter不同，Gauge类型的指标侧重于反应系统的当前状态。因此这类指标的样本数据可增可减。常见指标如：node_memory_MemFree（主机当前空闲的内存大小）、node_memory_MemAvailable（可用内存大小）都是Gauge类型的监控指标。</p>
<p>通过Gauge指标，用户可以直接查看系统的当前状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_MemFree</span><br></pre></td></tr></table></figure>

<p>对于Gauge类型的监控指标，通过PromQL内置函数delta()可以获取样本在一段时间返回内的变化情况。例如，计算CPU温度在两个小时内的差异：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta(cpu_temp_celsius&#123;host=&quot;zeus&quot;&#125;[2h])</span><br></pre></td></tr></table></figure>

<p>还可以使用deriv()计算样本的线性回归模型，甚至是直接使用predict_linear()对数据的变化趋势进行预测。例如，预测系统磁盘空间在4个小时之后的剩余情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free&#123;job=&quot;node&quot;&#125;[1h], 4 * 3600)</span><br></pre></td></tr></table></figure>

<h2 id="使用Histogram和Summary分析数据分布情况"><a href="#使用Histogram和Summary分析数据分布情况" class="headerlink" title="使用Histogram和Summary分析数据分布情况"></a>使用Histogram和Summary分析数据分布情况</h2><p>除了Counter和Gauge类型的监控指标以外，Prometheus还定义了Histogram和Summary的指标类型。Histogram和Summary主要用于统计和分析样本的分布情况。</p>
<p>在大多数情况下人们都倾向于使用某些量化指标的平均值，例如CPU的平均使用率、页面的平均响应时间。这种方式的问题很明显，以系统API调用的平均响应时间为例：如果大多数API请求都维持在100ms的响应时间范围内，而个别请求的响应时间需要5s，那么就会导致某些WEB页面的响应时间落到中位数的情况，而这种现象被称为长尾问题。</p>
<p>为了区分是平均的慢还是长尾的慢，最简单的方式就是按照请求延迟的范围进行分组。例如，统计延迟在0<del>10ms之间的请求数有多少而10</del>20ms之间的请求数又有多少。通过这种方式可以快速分析系统慢的原因。Histogram和Summary都是为了能够解决这样问题的存在，通过Histogram和Summary类型的监控指标，我们可以快速了解监控样本的分布情况。 </p>
<p>例如，指标prometheus_tsdb_wal_fsync_duration_seconds的指标类型为Summary。 它记录了Prometheus Server中wal_fsync处理的处理时间，通过访问Prometheus Server的&#x2F;metrics地址，可以获取到以下监控样本数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.</span><br><span class="line"># TYPE prometheus_tsdb_wal_fsync_duration_seconds summary</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile=&quot;0.5&quot;&#125; 0.012352463</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile=&quot;0.9&quot;&#125; 0.014458005</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile=&quot;0.99&quot;&#125; 0.017316173</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds_count 216</span><br></pre></td></tr></table></figure>

<p>从上面的样本中可以得知当前Prometheus Server进行wal_fsync操作的总次数为216次，耗时2.888716127000002s。其中中位数（quantile&#x3D;0.5）的耗时为0.012352463，9分位数（quantile&#x3D;0.9）的耗时为0.014458005s。</p>
<p>在Prometheus Server自身返回的样本数据中，我们还能找到类型为Histogram的监控指标prometheus_tsdb_compaction_chunk_range_bucket。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># HELP prometheus_tsdb_compaction_chunk_range Final time range of chunks on their first compaction</span><br><span class="line"># TYPE prometheus_tsdb_compaction_chunk_range histogram</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;100&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;400&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;1600&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;6400&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;25600&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;102400&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;409600&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;1.6384e+06&quot;&#125; 260</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;6.5536e+06&quot;&#125; 780</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;2.62144e+07&quot;&#125; 780</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;+Inf&quot;&#125; 780</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_sum 1.1540798e+09</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_count 780</span><br></pre></td></tr></table></figure>

<p>与Summary类型的指标相似之处在于Histogram类型的样本同样会反应当前指标的记录的总数(以_count作为后缀)以及其值的总量（以_sum作为后缀）。不同在于Histogram指标直接反应了在不同区间内样本的个数，区间通过标签len进行定义。</p>
<p>同时对于Histogram的指标，我们还可以通过histogram_quantile()函数计算出其值的分位数。不同在于Histogram通过histogram_quantile函数是在服务器端计算的分位数。 而Sumamry的分位数则是直接在客户端计算完成。因此对于分位数的计算而言，Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多的资源。反之对于客户端而言Histogram消耗的资源更少。在选择这两种方式时用户应该按照自己的实际场景进行选择。</p>
<h1 id="初识PromQL"><a href="#初识PromQL" class="headerlink" title="初识PromQL"></a>初识PromQL</h1><p>Prometheus通过指标名称（metrics name）以及对应的一组标签（labelset）唯一定义一条时间序列。指标名称反映了监控样本的基本标识，而label则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤，聚合，统计从而产生新的计算后的一条时间序列。</p>
<p>PromQL是Prometheus内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持。并且被广泛应用在Prometheus的日常应用当中，包括对数据查询、可视化、告警处理当中。可以这么说，PromQL是Prometheus所有应用场景的基础，理解和掌握PromQL是Prometheus入门的第一课。</p>
<h2 id="查询时间序列"><a href="#查询时间序列" class="headerlink" title="查询时间序列"></a>查询时间序列</h2><p>当Prometheus通过Exporter采集到相应的监控指标样本数据后，我们就可以通过PromQL对监控样本数据进行查询。</p>
<p>当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该表达式会返回指标名称为http_requests_total的所有时间序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;alerts&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;=(20889@1518096812.326)</span><br><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;graph&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;=(21287@1518096812.326)</span><br></pre></td></tr></table></figure>

<p>PromQL还支持用户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。</p>
<p>PromQL支持使用<code>=</code>和<code>!=</code>两种完全匹配模式：</p>
<ul>
<li>通过使用<code>label=value</code>可以选择那些标签满足表达式定义的时间序列；</li>
<li>反之使用<code>label!=value</code>则可以根据标签匹配排除时间序列；</li>
</ul>
<p>例如，如果我们只需要查询所有http_requests_total时间序列中满足标签instance为localhost:9090的时间序列，则可以使用如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;instance=&quot;localhost:9090&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>反之使用<code>instance!=&quot;localhost:9090&quot;</code>则可以排除这些时间序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;instance!=&quot;localhost:9090&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用完全匹配的方式对时间序列进行过滤以外，PromQL还可以支持使用正则表达式作为匹配条件，多个表达式之间使用<code>|</code>进行分离：</p>
<ul>
<li>使用<code>label=~regx</code>表示选择那些标签符合正则表达式定义的时间序列；</li>
<li>反之使用<code>label!~regx</code>进行排除；</li>
</ul>
<p>例如，如果想查询多个环节下的时间序列序列可以使用如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;environment=~&quot;staging|testing|development&quot;,method!=&quot;GET&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>直接通过类似于PromQL表达式<code>http_requests_total</code>查询时间序列时，会选择出所有属于该度量指标的时序的当前采样值，这样的返回结果我们称之为__瞬时向量__。而相应的这样的表达式称之为__瞬时向量表达式__。</p>
<p>而如果我们想过去一段时间范围内的样本数据时，我们则需要使用__区间向量表达式__。区间向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器<code>[]</code>进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>

<p>该表达式将会返回查询到的时间序列中最近5分钟的所有样本数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;alerts&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;=[</span><br><span class="line">    1@1518096812.326</span><br><span class="line">    1@1518096817.326</span><br><span class="line">    1@1518096822.326</span><br><span class="line">    1@1518096827.326</span><br><span class="line">    1@1518096832.326</span><br><span class="line">    1@1518096837.325</span><br><span class="line">]</span><br><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;graph&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;=[</span><br><span class="line">    4 @1518096812.326</span><br><span class="line">    4@1518096817.326</span><br><span class="line">    4@1518096822.326</span><br><span class="line">    4@1518096827.326</span><br><span class="line">    4@1518096832.326</span><br><span class="line">    4@1518096837.325</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>通过区间向量表达式查询到的结果我们称为__区间向量__。</p>
<p>除了使用m表示分钟以外，PromQL的时间范围选择器支持其它时间单位：</p>
<ul>
<li>s - 秒</li>
<li>m - 分钟</li>
<li>h - 小时</li>
<li>d - 天</li>
<li>w - 周</li>
<li>y - 年</li>
</ul>
<h2 id="时间位移操作"><a href="#时间位移操作" class="headerlink" title="时间位移操作"></a>时间位移操作</h2><p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125; # 瞬时向量表达式，选择当前最新的数据</span><br><span class="line">http_request_total&#123;&#125;[5m] # 区间向量表达式，选择以当前时间为基准，5分钟内的数据</span><br></pre></td></tr></table></figure>

<p>而如果我们想查询，5分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为<strong>offset</strong>。</p>
<p>可以使用offset时间位移操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125; offset 5m</span><br><span class="line">http_request_total&#123;&#125;[1d] offset 1d</span><br></pre></td></tr></table></figure>

<h2 id="使用聚合操作"><a href="#使用聚合操作" class="headerlink" title="使用聚合操作"></a>使用聚合操作</h2><p>一般来说，如果描述样本特征的标签(label)在并非唯一的情况下，通过PromQL查询数据，会返回多条满足这些特征维度的时间序列。而PromQL提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查询系统所有http请求的总量</span><br><span class="line">sum(http_request_total)</span><br><span class="line"></span><br><span class="line"># 按照mode计算主机CPU的平均使用时间</span><br><span class="line">avg(node_cpu) by (mode)</span><br><span class="line"></span><br><span class="line"># 按照主机查询各个主机的CPU使用率</span><br><span class="line">sum(sum(irate(node_cpu&#123;mode!=&#x27;idle&#x27;&#125;[5m]))  / sum(irate(node_cpu[5m]))) by (instance)</span><br></pre></td></tr></table></figure>

<h2 id="标量和字符串"><a href="#标量和字符串" class="headerlink" title="标量和字符串"></a>标量和字符串</h2><p>除了使用瞬时向量表达式和区间向量表达式以外，PromQL还直接支持用户使用标量(Scalar)和字符串(String)。</p>
<h3 id="标量（Scalar）：一个浮点型的数字值"><a href="#标量（Scalar）：一个浮点型的数字值" class="headerlink" title="标量（Scalar）：一个浮点型的数字值"></a>标量（Scalar）：一个浮点型的数字值</h3><p>标量只有一个数字，没有时序。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，当使用表达式count(http_requests_total)，返回的数据类型，依然是瞬时向量。用户可以通过内置函数scalar()将单个瞬时向量转换为标量。</p>
</blockquote>
<h3 id="字符串（String）：一个简单的字符串值"><a href="#字符串（String）：一个简单的字符串值" class="headerlink" title="字符串（String）：一个简单的字符串值"></a>字符串（String）：一个简单的字符串值</h3><p>直接使用字符串，作为PromQL表达式，则会直接返回字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;this is a string&quot;</span><br><span class="line">&#x27;these are unescaped: \n \\ \t&#x27;</span><br><span class="line">`these are not unescaped: \n &#x27; &quot; \t`</span><br></pre></td></tr></table></figure>

<h2 id="合法的PromQL表达式"><a href="#合法的PromQL表达式" class="headerlink" title="合法的PromQL表达式"></a>合法的PromQL表达式</h2><p>所有的PromQL表达式都必须至少包含一个指标名称(例如http_request_total)，或者一个不会匹配到空字符串的标签过滤器(例如{code&#x3D;”200”})。</p>
<p>因此以下两种方式，均为合法的表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http_request_total # 合法</span><br><span class="line">http_request_total&#123;&#125; # 合法</span><br><span class="line">&#123;method=&quot;get&quot;&#125; # 合法</span><br></pre></td></tr></table></figure>

<p>而如下表达式，则不合法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;job=~&quot;.*&quot;&#125; # 不合法</span><br></pre></td></tr></table></figure>

<p>同时，除了使用<code>&lt;metric name&gt;&#123;label=value&#125;</code>的形式以外，我们还可以使用内置的<code>__name__</code>标签来指定监控指标名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__=~&quot;http_request_total&quot;&#125; # 合法</span><br><span class="line">&#123;__name__=~&quot;node_disk_bytes_read|node_disk_bytes_written&quot;&#125; # 合法</span><br></pre></td></tr></table></figure>



<h1 id="PromQL操作符"><a href="#PromQL操作符" class="headerlink" title="PromQL操作符"></a>PromQL操作符</h1><p>使用PromQL除了能够方便的按照查询和过滤时间序列以外，PromQL还支持丰富的操作符，用户可以使用这些操作符对进一步的对事件序列进行二次加工。这些操作符包括：数学运算符，逻辑运算符，布尔运算符等等。</p>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>例如，我们可以通过指标node_memory_free_bytes_total获取当前主机可用的内存空间大小，其样本单位为Bytes。这时如果客户端要求使用MB作为单位响应数据，那只需要将查询到的时间序列的样本值进行单位换算即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_free_bytes_total / (1024 * 1024)</span><br></pre></td></tr></table></figure>

<p>node_memory_free_bytes_total表达式会查询出所有满足表达式条件的时间序列，在上一小节中我们称该表达式为瞬时向量表达式，而返回的结果成为瞬时向量。</p>
<p>当瞬时向量与标量之间进行数学运算时，数学运算符会依次作用于瞬时向量中的每一个样本值，从而得到一组新的时间序列。</p>
<p>而如果是瞬时向量与瞬时向量之间进行数学运算时，过程会相对复杂一点。 例如，如果我们想根据node_disk_bytes_written和node_disk_bytes_read获取主机磁盘IO的总量，可以使用如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_disk_bytes_written + node_disk_bytes_read</span><br></pre></td></tr></table></figure>

<p>那这个表达式是如何工作的呢？依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。同时新的时间序列将不会包含指标名称。 该表达式返回结果的示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;device=&quot;sda&quot;,instance=&quot;localhost:9100&quot;,job=&quot;node_exporter&quot;&#125;=&gt;1634967552@1518146427.807 + 864551424@1518146427.807</span><br><span class="line">&#123;device=&quot;sdb&quot;,instance=&quot;localhost:9100&quot;,job=&quot;node_exporter&quot;&#125;=&gt;0@1518146427.807 + 1744384@1518146427.807</span><br></pre></td></tr></table></figure>

<p>PromQL支持的所有数学运算符如下所示：</p>
<ul>
<li><code>+</code> (加法)</li>
<li><code>-</code> (减法)</li>
<li><code>*</code> (乘法)</li>
<li><code>/</code> (除法)</li>
<li><code>%</code> (求余)</li>
<li><code>^</code> (幂运算)</li>
</ul>
<h2 id="使用布尔运算过滤时间序列"><a href="#使用布尔运算过滤时间序列" class="headerlink" title="使用布尔运算过滤时间序列"></a>使用布尔运算过滤时间序列</h2><p>在PromQL通过标签匹配模式，用户可以根据时间序列的特征维度对其进行查询。而布尔运算则支持用户根据时间序列中样本的值，对时间序列进行过滤。</p>
<p>例如，通过数学运算符我们可以很方便的计算出，当前所有主机节点的内存使用率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total</span><br></pre></td></tr></table></figure>

<p>而系统管理员在排查问题的时候可能只想知道当前内存使用率超过95%的主机呢？通过使用布尔运算符可以方便的获取到该结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total &gt; 0.95</span><br></pre></td></tr></table></figure>

<p>瞬时向量与标量进行布尔运算时，PromQL依次比较向量中的所有时间序列样本的值，如果比较结果为true则保留，反之丢弃。</p>
<p>瞬时向量与瞬时向量直接进行布尔运算时，同样遵循默认的匹配模式：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行相应的操作，如果没找到匹配元素，则直接丢弃。</p>
<p>目前，Prometheus支持以下布尔运算符如下：</p>
<ul>
<li><code>==</code> (相等)</li>
<li><code>!=</code> (不相等)</li>
<li><code>&gt;</code> (大于)</li>
<li><code>&lt;</code> (小于)</li>
<li><code>&gt;=</code> (大于等于)</li>
<li><code>&lt;=</code> (小于等于)</li>
</ul>
<h2 id="使用bool修饰符改变布尔运算符的行为"><a href="#使用bool修饰符改变布尔运算符的行为" class="headerlink" title="使用bool修饰符改变布尔运算符的行为"></a>使用bool修饰符改变布尔运算符的行为</h2><p>布尔运算符的默认行为是对时序数据进行过滤。而在其它的情况下我们可能需要的是真正的布尔结果。例如，只需要知道当前模块的HTTP请求量是否&gt;&#x3D;1000，如果大于等于1000则返回1（true）否则返回0（false）。这时可以使用bool修饰符改变布尔运算的默认行为。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total &gt; bool 1000</span><br></pre></td></tr></table></figure>

<p>使用bool修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果0或者1。从而形成一条新的时间序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;query&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;  1</span><br><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;query_range&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;  0</span><br></pre></td></tr></table></figure>

<p>同时需要注意的是，如果是在两个标量之间使用布尔运算，则必须使用bool修饰符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 == bool 2 # 结果为1</span><br></pre></td></tr></table></figure>

<h2 id="使用集合运算符"><a href="#使用集合运算符" class="headerlink" title="使用集合运算符"></a>使用集合运算符</h2><p>使用瞬时向量表达式能够获取到一个包含多个时间序列的集合，我们称为瞬时向量。 通过集合运算，可以在两个瞬时向量与瞬时向量之间进行相应的集合操作。目前，Prometheus支持以下集合运算符：</p>
<ul>
<li><code>and</code> (并且)</li>
<li><code>or</code> (或者)</li>
<li><code>unless</code> (排除)</li>
</ul>
<p><em><strong>vector1 and vector2</strong></em> 会产生一个由vector1的元素组成的新的向量。该向量包含vector1中完全匹配vector2中的元素组成。</p>
<p><em><strong>vector1 or vector2</strong></em> 会产生一个新的向量，该向量包含vector1中所有的样本数据，以及vector2中没有与vector1匹配到的样本数据。</p>
<p><em><strong>vector1 unless vector2</strong></em> 会产生一个新的向量，新向量中的元素由vector1中没有与vector2匹配的元素组成。</p>
<h2 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h2><p>对于复杂类型的表达式，需要了解运算操作的运行优先级</p>
<p>例如，查询主机的CPU使用率，可以使用表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 * (1 - avg (irate(node_cpu&#123;mode=&#x27;idle&#x27;&#125;[5m])) by(job) )</span><br></pre></td></tr></table></figure>

<p>其中irate是PromQL中的内置函数，用于计算区间向量中时间序列每秒的即时增长率。关于内置函数的部分，会在下一节详细介绍。</p>
<p>在PromQL操作符中优先级由高到低依次为：</p>
<ol>
<li><code>^</code></li>
<li><code>*, /, %</code></li>
<li><code>+, -</code></li>
<li><code>==, !=, &lt;=, &lt;, &gt;=, &gt;</code></li>
<li><code>and, unless</code></li>
<li><code>or</code></li>
</ol>
<h2 id="匹配模式详解"><a href="#匹配模式详解" class="headerlink" title="匹配模式详解"></a>匹配模式详解</h2><p>向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。</p>
<p>接下来将介绍在PromQL中有两种典型的匹配模式：一对一（one-to-one）,多对一（many-to-one）或一对多（one-to-many）。</p>
<h3 id="一对一匹配"><a href="#一对一匹配" class="headerlink" title="一对一匹配"></a>一对一匹配</h3><p>一对一匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值。默认情况下，使用表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector1 &lt;operator&gt; vector2</span><br></pre></td></tr></table></figure>

<p>在操作符两边表达式标签不一致的情况下，可以使用on(label list)或者ignoring(label list）来修改标签的匹配行为。使用ignoreing可以在匹配时忽略某些标签。而on则用于将匹配行为限定在某些标签之内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure>

<p>例如当存在样本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;method=&quot;get&quot;, code=&quot;500&quot;&#125;  24</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;get&quot;, code=&quot;404&quot;&#125;  30</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;put&quot;, code=&quot;501&quot;&#125;  3</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;post&quot;, code=&quot;500&quot;&#125; 6</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;post&quot;, code=&quot;404&quot;&#125; 21</span><br><span class="line"></span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;get&quot;&#125;  600</span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;del&quot;&#125;  34</span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;post&quot;&#125; 120</span><br></pre></td></tr></table></figure>

<p>使用PromQL表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;code=&quot;500&quot;&#125; / ignoring(code) method:http_requests:rate5m</span><br></pre></td></tr></table></figure>

<p>该表达式会返回在过去5分钟内，HTTP请求状态码为500的在所有请求中的比例。如果没有使用ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</p>
<p>因此结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;method=&quot;get&quot;&#125;  0.04            //  24 / 600</span><br><span class="line">&#123;method=&quot;post&quot;&#125; 0.05            //   6 / 120</span><br></pre></td></tr></table></figure>

<p>同时由于method为put和del的样本找不到匹配项，因此不会出现在结果当中。</p>
<h3 id="多对一和一对多"><a href="#多对一和一对多" class="headerlink" title="多对一和一对多"></a>多对一和一对多</h3><p>多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与”多”侧的多个元素匹配的情况。在这种情况下，必须使用group修饰符：group_left或者group_right来确定哪一个向量具有更高的基数（充当“多”的角色）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure>

<p>多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用ignoring和on修饰符来排除或者限定匹配的标签列表。</p>
<p>例如,使用表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m</span><br></pre></td></tr></table></figure>

<p>该表达式中，左向量<code>method_code:http_errors:rate5m</code>包含两个标签method和code。而右向量<code>method:http_requests:rate5m</code>中只包含一个标签method，因此匹配时需要使用ignoring限定匹配的标签为code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素，因此该表达式的匹配模式为多对一，需要使用group修饰符group_left指定左向量具有更好的基数。</p>
<p>最终的运算结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;method=&quot;get&quot;, code=&quot;500&quot;&#125;  0.04            //  24 / 600</span><br><span class="line">&#123;method=&quot;get&quot;, code=&quot;404&quot;&#125;  0.05            //  30 / 600</span><br><span class="line">&#123;method=&quot;post&quot;, code=&quot;500&quot;&#125; 0.05            //   6 / 120</span><br><span class="line">&#123;method=&quot;post&quot;, code=&quot;404&quot;&#125; 0.175           //  21 / 120</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提醒：group修饰符只能在比较和数学运算符中使用。在逻辑运算and,unless和or才注意操作中默认与右向量中的所有元素进行匹配。</p>
</blockquote>
<h1 id="PromQL聚合操作"><a href="#PromQL聚合操作" class="headerlink" title="PromQL聚合操作"></a>PromQL聚合操作</h1><p>Prometheus还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。</p>
<ul>
<li><code>sum</code> (求和)</li>
<li><code>min</code> (最小值)</li>
<li><code>max</code> (最大值)</li>
<li><code>avg</code> (平均值)</li>
<li><code>stddev</code> (标准差)</li>
<li><code>stdvar</code> (标准方差)</li>
<li><code>count</code> (计数)</li>
<li><code>count_values</code> (对value进行计数)</li>
<li><code>bottomk</code> (后n条时序)</li>
<li><code>topk</code> (前n条时序)</li>
<li><code>quantile</code> (分位数)</li>
</ul>
<p>使用聚合操作的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</span><br></pre></td></tr></table></figure>

<p>其中只有<code>count_values</code>, <code>quantile</code>, <code>topk</code>, <code>bottomk</code>支持参数(parameter)。</p>
<p>without用于从计算结果中移除列举的标签，而保留其它标签。by则正好相反，结果向量中只保留列出的标签，其余标签则移除。通过without和by可以按照样本的问题对数据进行聚合。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total) without (instance)</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total) by (code,handler,job,method)</span><br></pre></td></tr></table></figure>

<p>如果只需要计算整个应用的HTTP请求总量，可以直接使用表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total)</span><br></pre></td></tr></table></figure>

<p>count_values用于时间序列中每一个样本值出现的次数。count_values会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count_values(&quot;count&quot;, http_requests_total)</span><br></pre></td></tr></table></figure>

<p>topk和bottomk则用于对样本值进行排序，返回当前样本值前n位，或者后n位的时间序列。</p>
<p>获取HTTP请求数前5位的时序样本数据，可以使用表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(5, http_requests_total)</span><br></pre></td></tr></table></figure>

<p>quantile用于计算当前样本数据值的分布情况quantile(φ, express)其中0 ≤ φ ≤ 1。</p>
<p>例如，当φ为0.5时，即表示找到当前样本数据中的中位数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(0.5, http_requests_total)</span><br></pre></td></tr></table></figure>



<h1 id="PromQL内置函数"><a href="#PromQL内置函数" class="headerlink" title="PromQL内置函数"></a>PromQL内置函数</h1><p>在上一小节中，我们已经看到了类似于irate()这样的函数，可以帮助我们计算监控指标的增长率。除了irate以外，Prometheus还提供了其它大量的内置函数，可以对时序数据进行丰富的处理。本小节将带读者了解一些常用的内置函数以及相关的使用场景和用法。</p>
<h2 id="计算Counter指标增长率"><a href="#计算Counter指标增长率" class="headerlink" title="计算Counter指标增长率"></a>计算Counter指标增长率</h2><p>我们知道Counter类型的监控指标其特点是只增不减，在没有发生重置（如服务器重启，应用重启）的情况下其样本值应该是不断增大的。为了能够更直观的表示样本数据的变化剧烈情况，需要计算样本的增长速率。</p>
<p>如下图所示，样本增长率反映出了样本变化的剧烈程度：</p>
<p><img src="/archives/de9e970e/counter-to-rate.png" alt="通过增长率表示样本的变化情况"></p>
<p>increase(v range-vector)函数是PromQL中提供的众多内置函数之一。其中参数v是一个区间向量，increase函数获取区间向量中的第一个后最后一个样本并返回其增长量。因此，可以通过以下表达式Counter类型指标的增长率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increase(node_cpu[2m]) / 120</span><br></pre></td></tr></table></figure>

<p>这里通过node_cpu[2m]获取时间序列最近两分钟的所有样本，increase计算出最近两分钟的增长量，最后除以时间120秒得到node_cpu样本在最近两分钟的平均增长率。并且这个值也近似于主机节点最近两分钟内的平均CPU使用率。</p>
<p>除了使用increase函数以外，PromQL中还直接内置了rate(v range-vector)函数，rate函数可以直接计算区间向量v在时间窗口内平均增长速率。因此，通过以下表达式可以得到与increase函数相同的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(node_cpu[2m])</span><br></pre></td></tr></table></figure>

<p>需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于主机而言在2分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致CPU占用100%的情况，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。</p>
<p>为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irate(node_cpu[2m])</span><br></pre></td></tr></table></figure>

<p>irate函数相比于rate函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate的这种灵敏度反而容易造成干扰。因此在长期趋势分析或者告警中更推荐使用rate函数。</p>
<h2 id="预测Gauge指标变化趋势"><a href="#预测Gauge指标变化趋势" class="headerlink" title="预测Gauge指标变化趋势"></a>预测Gauge指标变化趋势</h2><p>在一般情况下，系统管理员为了确保业务的持续可用运行，会针对服务器的资源设置相应的告警阈值。例如，当磁盘空间只剩512MB时向相关人员发送告警通知。 这种基于阈值的告警模式对于当资源用量是平滑增长的情况下是能够有效的工作的。 但是如果资源不是平滑变化的呢？ 比如有些某些业务增长，存储空间的增长速率提升了好几倍。这时，如果基于原有阈值去触发告警，当系统管理员接收到告警以后可能还没来得及去处理问题，系统就已经不可用了。 因此阈值通常来说不是固定的，需要定期进行调整才能保证该告警阈值能够发挥去作用。 那么还有没有更好的方法吗？</p>
<p>PromQL中内置的predict_linear(v range-vector, t scalar) 函数可以帮助系统管理员更好的处理此类情况，predict_linear函数可以预测时间序列v在t秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。例如，基于2小时的样本数据，来预测主机可用磁盘空间的是否在4个小时候被占满，可以使用如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free&#123;job=&quot;node&quot;&#125;[2h], 4 * 3600) &lt; 0</span><br></pre></td></tr></table></figure>

<h2 id="统计Histogram指标的分位数"><a href="#统计Histogram指标的分位数" class="headerlink" title="统计Histogram指标的分位数"></a>统计Histogram指标的分位数</h2><p>在本章的第2小节中，我们介绍了Prometheus的四种监控指标类型，其中Histogram和Summary都可以用于统计和分析数据的分布情况。区别在于Summary是直接在客户端计算了数据分布的分位数情况。而Histogram的分位数计算需要通过histogram_quantile(φ float, b instant-vector)函数进行计算。其中φ（0&lt;φ&lt;1）表示需要计算的分位数，如果需要计算中位数φ取值为0.5，以此类推即可。</p>
<p>以指标http_request_duration_seconds_bucket为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># HELP http_request_duration_seconds request duration histogram</span><br><span class="line"># TYPE http_request_duration_seconds histogram</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;0.5&quot;&#125; 0</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;1&quot;&#125; 1</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;2&quot;&#125; 2</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;3&quot;&#125; 3</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;5&quot;&#125; 3</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125; 3</span><br><span class="line">http_request_duration_seconds_sum 6</span><br><span class="line">http_request_duration_seconds_count 3</span><br></pre></td></tr></table></figure>

<p>当计算9分位数时，使用如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.5, http_request_duration_seconds_bucket)</span><br></pre></td></tr></table></figure>

<p>通过对Histogram类型的监控指标，用户可以轻松获取样本数据的分布情况。同时分位数的计算，也可以非常方便的用于评判当前监控指标的服务水平。</p>
<p><img src="/archives/de9e970e/histogram_quantile.png" alt="获取分布直方图的中位数"></p>
<p>需要注意的是通过histogram_quantile计算的分位数，并非为精确值，而是通过http_request_duration_seconds_bucket和http_request_duration_seconds_sum近似计算的结果。</p>
<h2 id="动态标签替换"><a href="#动态标签替换" class="headerlink" title="动态标签替换"></a>动态标签替换</h2><p>一般来说来说，使用PromQL查询到时间序列后，可视化工具会根据时间序列的标签来渲染图表。例如通过up指标可以获取到当前所有运行的Exporter实例以及其状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">up&#123;instance=&quot;localhost:8080&quot;,job=&quot;cadvisor&quot;&#125;	1</span><br><span class="line">up&#123;instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;&#125;	1</span><br><span class="line">up&#123;instance=&quot;localhost:9100&quot;,job=&quot;node&quot;&#125;	1</span><br></pre></td></tr></table></figure>

<p>这是可视化工具渲染图标时可能根据，instance和job的值进行渲染，为了能够让客户端的图标更具有可读性，可以通过label_replace标签为时间序列添加额外的标签。label_replace的具体参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)</span><br></pre></td></tr></table></figure>

<p>该函数会依次对v中的每一条时间序列进行处理，通过regex匹配src_label的值，并将匹配部分relacement写入到dst_label标签中。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;,  &quot;(.*):.*&quot;)</span><br></pre></td></tr></table></figure>

<p>函数处理后，时间序列将包含一个host标签，host标签的值为Exporter实例的IP地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">up&#123;host=&quot;localhost&quot;,instance=&quot;localhost:8080&quot;,job=&quot;cadvisor&quot;&#125;	1</span><br><span class="line">up&#123;host=&quot;localhost&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;&#125;	1</span><br><span class="line">up&#123;host=&quot;localhost&quot;,instance=&quot;localhost:9100&quot;,job=&quot;node&quot;&#125; 1</span><br></pre></td></tr></table></figure>

<p>除了label_replace以外，Prometheus还提供了label_join函数，该函数可以将时间序列中v多个标签src_label的值，通过separator作为连接符写入到一个新的标签dst_label中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)</span><br></pre></td></tr></table></figure>

<p>label_replace和label_join函数提供了对时间序列标签的自定义能力，从而能够更好的于客户端或者可视化工具配合。</p>
<h2 id="其它内置函数"><a href="#其它内置函数" class="headerlink" title="其它内置函数"></a>其它内置函数</h2><p>除了上文介绍的这些内置函数以外，PromQL还提供了大量的其它内置函数。这些内置函数包括一些常用的数学计算、日期等等。这里就不一一细讲，感兴趣的读者可以通过阅读Prometheus的官方文档，了解这些函数的使用方式。</p>
<h1 id="在HTTP-API中使用PromQL"><a href="#在HTTP-API中使用PromQL" class="headerlink" title="在HTTP API中使用PromQL"></a>在HTTP API中使用PromQL</h1><p>Prometheus当前稳定的HTTP API可以通过&#x2F;api&#x2F;v1访问。</p>
<h2 id="API响应格式"><a href="#API响应格式" class="headerlink" title="API响应格式"></a>API响应格式</h2><p>Prometheus API使用了JSON格式的响应内容。 当API调用成功后将会返回2xx的HTTP状态码。</p>
<p>反之，当API调用失败时可能返回以下几种不同的HTTP状态码：</p>
<ul>
<li>404 Bad Request：当参数错误或者缺失时。</li>
<li>422 Unprocessable Entity 当表达式无法执行时。</li>
<li>503 Service Unavailiable 当请求超时或者被中断时。</li>
</ul>
<p>所有的API请求均使用以下的JSON格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot; | &quot;error&quot;,</span><br><span class="line">  &quot;data&quot;: &lt;data&gt;,</span><br><span class="line"></span><br><span class="line">  // Only set if status is &quot;error&quot;. The data field may still hold</span><br><span class="line">  // additional data.</span><br><span class="line">  &quot;errorType&quot;: &quot;&lt;string&gt;&quot;,</span><br><span class="line">  &quot;error&quot;: &quot;&lt;string&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="在HTTP-API中使用PromQL-1"><a href="#在HTTP-API中使用PromQL-1" class="headerlink" title="在HTTP API中使用PromQL"></a>在HTTP API中使用PromQL</h2><p>通过HTTP API我们可以分别通过&#x2F;api&#x2F;v1&#x2F;query和&#x2F;api&#x2F;v1&#x2F;query_range查询PromQL表达式当前或者一定时间范围内的计算结果。</p>
<h3 id="瞬时数据查询"><a href="#瞬时数据查询" class="headerlink" title="瞬时数据查询"></a>瞬时数据查询</h3><p>通过使用QUERY API我们可以查询PromQL在特定时间点下的计算结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/query</span><br></pre></td></tr></table></figure>

<p>URL请求参数：</p>
<ul>
<li>query&#x3D;<string>：PromQL表达式。</li>
<li>time&#x3D;&lt;rfc3339 | unix_timestamp&gt;：用于指定用于计算PromQL的时间戳。可选参数，默认情况下使用当前系统时间。</li>
<li>timeout&#x3D;<duration>：超时设置。可选参数，默认情况下使用-query,timeout的全局设置。</li>
</ul>
<p>例如使用以下表达式查询表达式up在时间点2015-07-01T20:10:51.781Z的计算结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ curl &#x27;http://localhost:9090/api/v1/query?query=up&amp;time=2015-07-01T20:10:51.781Z&#x27;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;status&quot; : &quot;success&quot;,</span><br><span class="line">   &quot;data&quot; : &#123;</span><br><span class="line">      &quot;resultType&quot; : &quot;vector&quot;,</span><br><span class="line">      &quot;result&quot; : [</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;metric&quot; : &#123;</span><br><span class="line">               &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">               &quot;job&quot; : &quot;prometheus&quot;,</span><br><span class="line">               &quot;instance&quot; : &quot;localhost:9090&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;value&quot;: [ 1435781451.781, &quot;1&quot; ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;metric&quot; : &#123;</span><br><span class="line">               &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">               &quot;job&quot; : &quot;node&quot;,</span><br><span class="line">               &quot;instance&quot; : &quot;localhost:9100&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;value&quot; : [ 1435781451.781, &quot;0&quot; ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="响应数据类型"><a href="#响应数据类型" class="headerlink" title="响应数据类型"></a>响应数据类型</h3><p>当API调用成功后，Prometheus会返回JSON格式的响应内容，格式如上小节所示。并且在data节点中返回查询结果。data节点格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;resultType&quot;: &quot;matrix&quot; | &quot;vector&quot; | &quot;scalar&quot; | &quot;string&quot;,</span><br><span class="line">  &quot;result&quot;: &lt;value&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PromQL表达式可能返回多种数据类型，在响应内容中使用resultType表示当前返回的数据类型，包括：</p>
<ul>
<li>瞬时向量：vector</li>
</ul>
<p>当返回数据类型resultType为vector时，result响应格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;metric&quot;: &#123; &quot;&lt;label_name&gt;&quot;: &quot;&lt;label_value&gt;&quot;, ... &#125;,</span><br><span class="line">    &quot;value&quot;: [ &lt;unix_time&gt;, &quot;&lt;sample_value&gt;&quot; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中metrics表示当前时间序列的特征维度，value只包含一个唯一的样本。</p>
<ul>
<li>区间向量：matrix</li>
</ul>
<p>当返回数据类型resultType为matrix时，result响应格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;metric&quot;: &#123; &quot;&lt;label_name&gt;&quot;: &quot;&lt;label_value&gt;&quot;, ... &#125;,</span><br><span class="line">    &quot;values&quot;: [ [ &lt;unix_time&gt;, &quot;&lt;sample_value&gt;&quot; ], ... ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中metrics表示当前时间序列的特征维度，values包含当前事件序列的一组样本。</p>
<ul>
<li>标量：scalar</li>
</ul>
<p>当返回数据类型resultType为scalar时，result响应格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;unix_time&gt;, &quot;&lt;scalar_value&gt;&quot; ]</span><br></pre></td></tr></table></figure>

<p>由于标量不存在时间序列一说，因此result表示为当前系统时间一个标量的值。</p>
<ul>
<li>字符串：string</li>
</ul>
<p>当返回数据类型resultType为string时，result响应格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;unix_time&gt;, &quot;&lt;string_value&gt;&quot; ]</span><br></pre></td></tr></table></figure>

<p>字符串类型的响应内容格式和标量相同。</p>
<h3 id="区间数据查询"><a href="#区间数据查询" class="headerlink" title="区间数据查询"></a>区间数据查询</h3><p>使用QUERY_RANGE API我们则可以直接查询PromQL表达式在一段时间返回内的计算结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/query_range</span><br></pre></td></tr></table></figure>

<p>URL请求参数：</p>
<ul>
<li>query&#x3D;<string>: PromQL表达式。</li>
<li>start&#x3D;&lt;rfc3339 | unix_timestamp&gt;: 起始时间。</li>
<li>end&#x3D;&lt;rfc3339 | unix_timestamp&gt;: 结束时间。</li>
<li>step&#x3D;<duration>: 查询步长。</li>
<li>timeout&#x3D;<duration>: 超时设置。可选参数，默认情况下使用-query,timeout的全局设置。</li>
</ul>
<p>当使用QUERY_RANGE API查询PromQL表达式时，返回结果一定是一个区间向量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;resultType&quot;: &quot;matrix&quot;,</span><br><span class="line">  &quot;result&quot;: &lt;value&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，在QUERY_RANGE API中PromQL只能使用瞬时向量选择器类型的表达式。</p>
</blockquote>
<p>例如使用以下表达式查询表达式up在30秒范围内以15秒为间隔计算PromQL表达式的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ curl &#x27;http://localhost:9090/api/v1/query_range?query=up&amp;start=2015-07-01T20:10:30.781Z&amp;end=2015-07-01T20:11:00.781Z&amp;step=15s&#x27;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;status&quot; : &quot;success&quot;,</span><br><span class="line">   &quot;data&quot; : &#123;</span><br><span class="line">      &quot;resultType&quot; : &quot;matrix&quot;,</span><br><span class="line">      &quot;result&quot; : [</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;metric&quot; : &#123;</span><br><span class="line">               &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">               &quot;job&quot; : &quot;prometheus&quot;,</span><br><span class="line">               &quot;instance&quot; : &quot;localhost:9090&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;values&quot; : [</span><br><span class="line">               [ 1435781430.781, &quot;1&quot; ],</span><br><span class="line">               [ 1435781445.781, &quot;1&quot; ],</span><br><span class="line">               [ 1435781460.781, &quot;1&quot; ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;metric&quot; : &#123;</span><br><span class="line">               &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">               &quot;job&quot; : &quot;node&quot;,</span><br><span class="line">               &quot;instance&quot; : &quot;localhost:9091&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;values&quot; : [</span><br><span class="line">               [ 1435781430.781, &quot;0&quot; ],</span><br><span class="line">               [ 1435781445.781, &quot;0&quot; ],</span><br><span class="line">               [ 1435781460.781, &quot;1&quot; ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="最佳实践：4个黄金指标和USE方法"><a href="#最佳实践：4个黄金指标和USE方法" class="headerlink" title="最佳实践：4个黄金指标和USE方法"></a>最佳实践：4个黄金指标和USE方法</h1><p>前面部分介绍了Prometheus的数据存储模型以及4种指标类型，同时Prometheus提供的强大的PromQL可以实现对数据的个性化处理。Prometheus基于指标提供了一个通用的监控解决方案。这里先思考一个基本的问题，在实现监控时，我们到底应该监控哪些对象以及哪些指标？</p>
<h2 id="监控所有"><a href="#监控所有" class="headerlink" title="监控所有"></a>监控所有</h2><p>在之前<strong>Prometheus简介</strong>部分介绍监控的基本目标，首先是及时发现问题，其次是要能够快速对问题进行定位。对于传统监控解决方案而言，用户看到的依然是一个黑盒，用户无法真正了解系统的真正的运行状态。因此Prometheus鼓励用户监控所有的东西。下面列举一些常用的监控维度。</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>监控什么</th>
<th>Exporter</th>
</tr>
</thead>
<tbody><tr>
<td>网络</td>
<td>网络协议：http、dns、tcp、icmp；网络硬件：路由器，交换机等</td>
<td>BlackBox Exporter;SNMP Exporter</td>
</tr>
<tr>
<td>主机</td>
<td>资源用量</td>
<td>node exporter</td>
</tr>
<tr>
<td>容器</td>
<td>资源用量</td>
<td>cAdvisor</td>
</tr>
<tr>
<td>应用(包括Library)</td>
<td>延迟，错误，QPS，内部状态等</td>
<td>代码中集成Prmometheus Client</td>
</tr>
<tr>
<td>中间件状态</td>
<td>资源用量，以及服务状态</td>
<td>代码中集成Prmometheus Client</td>
</tr>
<tr>
<td>编排工具</td>
<td>集群资源用量，调度等</td>
<td>Kubernetes Components</td>
</tr>
</tbody></table>
<h2 id="监控模式"><a href="#监控模式" class="headerlink" title="监控模式"></a>监控模式</h2><p>除了上述介绍的不同监控级别以外。实际上根据不同的系统类型和目标，这里还有一些通用的套路和模式可以使用。</p>
<h2 id="4个黄金指标"><a href="#4个黄金指标" class="headerlink" title="4个黄金指标"></a>4个黄金指标</h2><p>Four Golden Signals是Google针对大量分布式监控的经验总结，4个黄金指标可以在服务级别帮助衡量终端用户体验、服务中断、业务影响等层面的问题。主要关注与以下四种类型的指标：延迟，通讯量，错误以及饱和度：</p>
<ul>
<li>延迟：服务请求所需时间。</li>
</ul>
<p>记录用户所有请求所需的时间，重点是要区分成功请求的延迟时间和失败请求的延迟时间。 例如在数据库或者其他关键祸端服务异常触发HTTP 500的情况下，用户也可能会很快得到请求失败的响应内容，如果不加区分计算这些请求的延迟，可能导致计算结果与实际结果产生巨大的差异。除此以外，在微服务中通常提倡“快速失败”，开发人员需要特别注意这些延迟较大的错误，因为这些缓慢的错误会明显影响系统的性能，因此追踪这些错误的延迟也是非常重要的。</p>
<ul>
<li>通讯量：监控当前系统的流量，用于衡量服务的容量需求。</li>
</ul>
<p>流量对于不同类型的系统而言可能代表不同的含义。例如，在HTTP REST API中, 流量通常是每秒HTTP请求数；</p>
<ul>
<li>错误：监控当前系统所有发生的错误请求，衡量当前系统错误发生的速率。</li>
</ul>
<p>对于失败而言有些是显式的(比如, HTTP 500错误)，而有些是隐式(比如，HTTP响应200，但实际业务流程依然是失败的)。</p>
<p>对于一些显式的错误如HTTP 500可以通过在负载均衡器(如Nginx)上进行捕获，而对于一些系统内部的异常，则可能需要直接从服务中添加钩子统计并进行获取。</p>
<ul>
<li>饱和度：衡量当前服务的饱和度。</li>
</ul>
<p>主要强调最能影响服务状态的受限制的资源。 例如，如果系统主要受内存影响，那就主要关注系统的内存状态，如果系统主要受限于磁盘I&#x2F;O，那就主要观测磁盘I&#x2F;O的状态。因为通常情况下，当这些资源达到饱和后，服务的性能会明显下降。同时还可以利用饱和度对系统做出预测，比如，“磁盘是否可能在4个小时候就满了”。</p>
<h2 id="RED方法"><a href="#RED方法" class="headerlink" title="RED方法"></a>RED方法</h2><p>RED方法是Weave Cloud在基于Google的“4个黄金指标”的原则下结合Prometheus以及Kubernetes容器实践，细化和总结的方法论，特别适合于云原生应用以及微服务架构应用的监控和度量。主要关注以下三种关键指标：</p>
<ul>
<li>(请求)速率：服务每秒接收的请求数。</li>
<li>(请求)错误：每秒失败的请求数。</li>
<li>(请求)耗时：每个请求的耗时。</li>
</ul>
<p>在“4大黄金信号”的原则下，RED方法可以有效的帮助用户衡量云原生以及微服务应用下的用户体验问题。</p>
<h2 id="USE方法"><a href="#USE方法" class="headerlink" title="USE方法"></a>USE方法</h2><p>USE方法全称”Utilization Saturation and Errors Method”，主要用于分析系统性能问题，可以指导用户快速识别资源瓶颈以及错误的方法。正如USE方法的名字所表示的含义，USE方法主要关注与资源的：使用率(Utilization)、饱和度(Saturation)以及错误(Errors)。</p>
<ul>
<li>使用率：关注系统资源的使用情况。 这里的资源主要包括但不限于：CPU，内存，网络，磁盘等等。100%的使用率通常是系统性能瓶颈的标志。</li>
<li>饱和度：例如CPU的平均运行排队长度，这里主要是针对资源的饱和度(注意，不同于4大黄金信号)。任何资源在某种程度上的饱和都可能导致系统性能的下降。</li>
<li>错误：错误计数。例如：“网卡在数据包传输过程中检测到的以太网网络冲突了14次”。</li>
</ul>
<p>通过对资源以上指标持续观察，通过以下流程可以知道用户识别资源瓶颈：</p>
<p><img src="/archives/de9e970e/USEMethod.png" alt="识别资源瓶颈"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.xiaowangc.com">尤妤</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.xiaowangc.com/archives/de9e970e.html">https://www.xiaowangc.com/archives/de9e970e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.xiaowangc.com" target="_blank">尤妤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Prometheus/">Prometheus</a><a class="post-meta__tags" href="/tags/%E7%9B%91%E6%8E%A7/">监控</a></div><div class="post_share"><div class="social-share" data-image="/img/fengmian/Prometheus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/archives/5b1fc607.html"><img class="prev-cover" src="/img/fengmian/k8s.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kubernetes网络策略</div></div></a></div><div class="next-post pull-right"><a href="/archives/4d672e21.html"><img class="next-cover" src="/img/fengmian/gitlab.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AWT is not properly configured on this server.</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/archives/b87e9ddb.html" title="Prometheus-基础"><img class="cover" src="/img/fengmian/Prometheus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-20</div><div class="title">Prometheus-基础</div></div></a></div><div><a href="/archives/762f83eb.html" title="Prometheus-查询"><img class="cover" src="/img/fengmian/Prometheus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-22</div><div class="title">Prometheus-查询</div></div></a></div><div><a href="/archives/446ae31b.html" title="Prometheus-Alertmanager"><img class="cover" src="/img/fengmian/Prometheus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-23</div><div class="title">Prometheus-Alertmanager</div></div></a></div><div><a href="/archives/dc8c870.html" title="Prometheus-NodeExport"><img class="cover" src="/img/fengmian/Prometheus.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-21</div><div class="title">Prometheus-NodeExport</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">尤妤</div><div class="author-info__description">欢迎来到尤妤的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=780312916&amp;site=qq&amp;menu=yes"><i class="fa-brands fa-qq"></i><span>联系尤妤</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:admin@xiaowangc.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.xiaowangc.com/baidusitemap.xml" target="_blank" title="站点地图"><i class="fas fa-map-location-dot"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果阅读过程中遇到了问题，请联系尤妤</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">理解时间序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E6%9C%AC"><span class="toc-number">1.1.</span> <span class="toc-text">样本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%A0%87-Metric"><span class="toc-number">1.2.</span> <span class="toc-text">指标(Metric)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Metric%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Metric类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Counter%EF%BC%9A%E5%8F%AA%E5%A2%9E%E4%B8%8D%E5%87%8F%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">Counter：只增不减的计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gauge%EF%BC%9A%E5%8F%AF%E5%A2%9E%E5%8F%AF%E5%87%8F%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98"><span class="toc-number">2.2.</span> <span class="toc-text">Gauge：可增可减的仪表盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Histogram%E5%92%8CSummary%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-number">2.3.</span> <span class="toc-text">使用Histogram和Summary分析数据分布情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E8%AF%86PromQL"><span class="toc-number">3.</span> <span class="toc-text">初识PromQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">查询时间序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.2.</span> <span class="toc-text">范围查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">时间位移操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.</span> <span class="toc-text">使用聚合操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">标量和字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%EF%BC%88Scalar%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%9A%84%E6%95%B0%E5%AD%97%E5%80%BC"><span class="toc-number">3.5.1.</span> <span class="toc-text">标量（Scalar）：一个浮点型的数字值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC"><span class="toc-number">3.5.2.</span> <span class="toc-text">字符串（String）：一个简单的字符串值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%B3%95%E7%9A%84PromQL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">合法的PromQL表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PromQL%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">PromQL操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.</span> <span class="toc-text">数学运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E8%BF%87%E6%BB%A4%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">使用布尔运算过滤时间序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8bool%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%94%B9%E5%8F%98%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.3.</span> <span class="toc-text">使用bool修饰符改变布尔运算符的行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">使用集合运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.5.</span> <span class="toc-text">操作符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.6.</span> <span class="toc-text">匹配模式详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E5%8C%B9%E9%85%8D"><span class="toc-number">4.6.1.</span> <span class="toc-text">一对一匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%92%8C%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-number">4.6.2.</span> <span class="toc-text">多对一和一对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PromQL%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">PromQL聚合操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PromQL%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">PromQL内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97Counter%E6%8C%87%E6%A0%87%E5%A2%9E%E9%95%BF%E7%8E%87"><span class="toc-number">6.1.</span> <span class="toc-text">计算Counter指标增长率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8BGauge%E6%8C%87%E6%A0%87%E5%8F%98%E5%8C%96%E8%B6%8B%E5%8A%BF"><span class="toc-number">6.2.</span> <span class="toc-text">预测Gauge指标变化趋势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1Histogram%E6%8C%87%E6%A0%87%E7%9A%84%E5%88%86%E4%BD%8D%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">统计Histogram指标的分位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A0%87%E7%AD%BE%E6%9B%BF%E6%8D%A2"><span class="toc-number">6.4.</span> <span class="toc-text">动态标签替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">其它内置函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8HTTP-API%E4%B8%AD%E4%BD%BF%E7%94%A8PromQL"><span class="toc-number">7.</span> <span class="toc-text">在HTTP API中使用PromQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">API响应格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8HTTP-API%E4%B8%AD%E4%BD%BF%E7%94%A8PromQL-1"><span class="toc-number">7.2.</span> <span class="toc-text">在HTTP API中使用PromQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9E%AC%E6%97%B6%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.2.1.</span> <span class="toc-text">瞬时数据查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">响应数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.2.3.</span> <span class="toc-text">区间数据查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A4%E4%B8%AA%E9%BB%84%E9%87%91%E6%8C%87%E6%A0%87%E5%92%8CUSE%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">最佳实践：4个黄金指标和USE方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%89%80%E6%9C%89"><span class="toc-number">8.1.</span> <span class="toc-text">监控所有</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">监控模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E4%B8%AA%E9%BB%84%E9%87%91%E6%8C%87%E6%A0%87"><span class="toc-number">8.3.</span> <span class="toc-text">4个黄金指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RED%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">RED方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USE%E6%96%B9%E6%B3%95"><span class="toc-number">8.5.</span> <span class="toc-text">USE方法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/bc2a8490.html" title="Linux证书有效期检测脚本"><img src="/img/fengmian/linux.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux证书有效期检测脚本"/></a><div class="content"><a class="title" href="/archives/bc2a8490.html" title="Linux证书有效期检测脚本">Linux证书有效期检测脚本</a><time datetime="2023-01-21T18:51:55.000Z" title="发表于 2023-01-22 02:51:55">2023-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/e3278faf.html" title="关于Kubernetes配置私有镜像仓库"><img src="/img/fengmian/k8s.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于Kubernetes配置私有镜像仓库"/></a><div class="content"><a class="title" href="/archives/e3278faf.html" title="关于Kubernetes配置私有镜像仓库">关于Kubernetes配置私有镜像仓库</a><time datetime="2023-01-21T09:19:38.000Z" title="发表于 2023-01-21 17:19:38">2023-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/d89a6add.html" title="Containerd安装脚本"><img src="/img/fengmian/k8s.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Containerd安装脚本"/></a><div class="content"><a class="title" href="/archives/d89a6add.html" title="Containerd安装脚本">Containerd安装脚本</a><time datetime="2023-01-20T12:03:22.000Z" title="发表于 2023-01-20 20:03:22">2023-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/93a87db7.html" title="ES&amp;Kibana安装配置"><img src="/img/fengmian/elastic_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES&amp;Kibana安装配置"/></a><div class="content"><a class="title" href="/archives/93a87db7.html" title="ES&amp;Kibana安装配置">ES&amp;Kibana安装配置</a><time datetime="2023-01-10T07:32:11.000Z" title="发表于 2023-01-10 15:32:11">2023-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/bd4820af.html" title="Poste.io邮件服务器"><img src="/img/fengmian/email.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Poste.io邮件服务器"/></a><div class="content"><a class="title" href="/archives/bd4820af.html" title="Poste.io邮件服务器">Poste.io邮件服务器</a><time datetime="2022-12-16T02:39:37.000Z" title="发表于 2022-12-16 10:39:37">2022-12-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/fengmian/Prometheus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 尤妤</div><div class="framework-info"><span><a href="https://hexo.io/" target="_blank" title="由 Halo 强力驱动" style="text-decoration:none;"><span style="color: #fff;border-bottom-left-radius: 4px;border-top-left-radius: 4px;background-color: #505050;padding: 1px 3px 1px 3px;" ><img src="https://www.xiaowangc.com/img/hexo.png" style="vertical-align:text-bottom">&nbsp</i>Powered</span><span data-v-625f2a9e="" style="color: #fff;padding: 1px 3px 1px 3px;background-color: #007ec6!important;border-top-right-radius: 4px;border-bottom-right-radius: 4px;">Hexo v6.2.0</span></a></span>
<span><a href="https://cloud.tencent.com/" target="_blank" title="由Tencent Cloud托管" style="text-decoration:none;"><span style="color: #fff;border-bottom-left-radius: 4px;border-top-left-radius: 4px;background-color: #505050;padding: 1px 3px 1px 3px;" ><i class="fa-brands fa-docker">&nbsp</i>Trusteeship</span><span data-v-625f2a9e="" style="color: #fff;padding: 1px 3px 1px 3px;background-color: #44e0c0!important;border-top-right-radius: 4px;border-bottom-right-radius: 4px;">Tencent Cloud</span></a></span>
<span><a href="https://beian.miit.gov.cn/" target="_blank" title="ICP备案" style="text-decoration:none;"><span style="color: #fff;border-bottom-left-radius: 4px;border-top-left-radius: 4px;background-color: #505050;padding: 1px 3px 1px 3px;"><img src="https://www.xiaowangc.com/img/icp.png" style="vertical-align:text-bottom">&nbsp</i>蜀ICP备</span><span data-v-625f2a9e="" style="color: #fff;padding: 1px 3px 1px 3px;background-color: red!important;border-top-right-radius: 4px;border-bottom-right-radius: 4px;">2022002393-1号</span></a></span>
<span><a href="https://icp.gov.moe/" target="_blank" title="萌国备案" style="text-decoration:none;"><span style="color: #fff;border-bottom-left-radius: 4px;border-top-left-radius: 4px;background-color: #505050;padding: 1px 3px 1px 3px;"><img src="https://www.xiaowangc.com/img/mb.ico" style="vertical-align:text-bottom">&nbsp</i>萌备</span><span data-v-625f2a9e="" style="color: #fff;padding: 1px 3px 1px 3px;background-color: orange!important;border-top-right-radius: 4px;border-bottom-right-radius: 4px;">20220706号</span></a></span>
<span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" title="主题" style="text-decoration:none;"><span style="color: #fff;border-bottom-left-radius: 4px;border-top-left-radius: 4px;background-color: #505050;padding: 1px 3px 1px 3px;"><i class="fa-brands fa-github"></i>&nbsp</i>Theme</span><span data-v-625f2a9e="" style="color: #fff;padding: 1px 3px 1px 3px;background-color: #4dc820!important;border-top-right-radius: 4px;border-bottom-right-radius: 4px;">Butterfly</span></a></span></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" style="text-decoration:none;"><span>本网站由</span><img src="https://www.xiaowangc.com/img/y_logo5.png" width="48" height="24" style="vertical-align:text-bottom"></img><span>提供CDN加速/云存储服务</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax defer src="https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>